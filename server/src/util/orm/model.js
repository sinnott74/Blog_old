module.exports = Model;

const DataTypes = require('./datatypes');
const Sql = require('sql');
const Query = require('./query');
const Attribute = require('./attribute');
const Util = require('./util');
const RecordNotFoundException = require('../../exception/RecordNotFoundException');
const MultipleRecordsFoundException = require('../../exception/RecordNotFoundException');

require('./associations');
require('./hooks');

/************************************************************************************
 ******                         MODEL CLASS METHODS                            ******
  ************************************************************************************/

/**
 * Class method which Initialize a model, representing a table in the DB, with attributes and options.
 *
 * For a list of possible data types, see {@link DataTypes}
 * @return {Model}
 */
Model.init = function(attributes, options) {

  if (!options.modelName) {
    throw new Error('Model name required');
  }
  Util.defineImmutableProperty(this, 'name', options.modelName);

  this.options = {
    schema: 'public',
    indexes: [],
    timestamps: false, // adding createdAt & updatedAt attributes
    optimisticLocking: false,
    ...options
  }

  this.associations = {};

  this.rawAttributes = {
    ...attributes
  };

  this._configureCommonAttributes();
  this._configureAttributeGettersAndSetters();
  this.refreshAttributes();
}

/**
 * Class methor which Configures the common attributes. e.g. id, versionNo, etc
 * Requires this.attributes & this.options have been set
 */
Model._configureCommonAttributes = function() {

  // Add ID - Primary Key
  this.rawAttributes = {
    id: {
      type: DataTypes.INT,
      notNull: true,
      primaryKey: true,
      autoIncrement: true,
      _autoGenerated: true
    },
    ...this.rawAttributes
  }

  // Add createdAt & updatedAt attributes
  if(this.options.timestamps) {
    this.rawAttributes = {
      ...this.rawAttributes,
      createdAt: {
        type: DataTypes.TIMESTAMP,
        notNull: true,
        _autoGenerated: true

      },
      updatedAt: {
        type: DataTypes.TIMESTAMP,
        notNull: true,
        _autoGenerated: true
      }
    }
  }

  // Add versionNo attribute
  if(this.options.optimisticLocking){
    this.rawAttributes = {
      ...this.rawAttributes,
      versionNo: {
        type: DataTypes.INT,
        notNull: true,
        defaultValue: 0,
        _autoGenerated: true
      }
    }
  }
}

/**
 * Class method which Adds a getter & setter for each raw attribute onto the model's prototype.
 *
 * Also adds an custom raw attribute getter & setter onto the model's prototypes _custom property.
 */
Model._configureAttributeGettersAndSetters = function() {

  // Create getter & setters for attributes
  const _self = this;
  Object.keys(_self.rawAttributes).forEach((attributeName) => {

    let attribute = _self.rawAttributes[attributeName];
    Util.defineGetterAndSetter(_self, attributeName);

    // Define custom attribute getters & setters
    // if (attribute.hasOwnProperty('get')) {
    //   this.prototype._customGetters[attributeName] = attribute.get;
    // }
    // if (attribute.hasOwnProperty('set')) {
    //   this.prototype._customSetters[attributeName] = attribute.set;
    // }
  })

  // TODO
  // Create custom properties/attributes
}

/**
 * Class method which Converts the Raw Attributes & Options in a object that is exected by the Package SQL.
 */
Model._convertToSQLConiguration = function() {

  const columns = Object.keys(this.rawAttributes).map((attributeName) => {
    let attribute = this.rawAttributes[attributeName];
    return {
      name: attributeName,
      ...attribute,
      dataType: attribute.type.getSQLType(attribute)
    }
  })

  this.sqlConfig = {
    name: this.options.modelName,
    schema: this.options.schema,
    columns
  };

  this.entity = Sql.define(this.sqlConfig);
}

Model.refreshAttributes = function() {
  this._convertToSQLConiguration();
}

/**
 * Filters out attributes which aren't defined in the Entity Definitiion
 * @param {*} entity
 * @returns {*} Entity which contains only attributes in the entity definitition
 */
Model._filterAttributesByDefinition = function(entity) {
  let attributes= Object.keys(entity);
  let definedAttributes = this.sqlConfig.columns.map(definedAttribute => definedAttribute.name);
  let filteredEntity = {};
  attributes.forEach((attribute) => {
    if(definedAttributes.includes(attribute)){
      filteredEntity[attribute] = entity[attribute];
    }
  });
  return filteredEntity;
}

/**
 * Class Method which reads a Entity by its primary key.
 * @param {Integer}     id ID of the entity
 * @throws RecordNotFoundException if no row with the given primary key is found
 * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
 */
Model.get = async function(id, options) {
  return this.findOne({id: id}, options);
}

/**
 * Class Method which reads a Entity by its primary key.
 * @param {object}     key Attribute - Value object of which only 1 record should exist
 * @throws RecordNotFoundException if no row with the given primary key is found
 * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
 * @return {Model}
 */
Model.findOne = async function(key, options) {
  let model = await this.findAtMostOne(key, options);
  if (!model) {
    throw new RecordNotFoundException(`Record Not Found on ${this.name} with Key ${key.toJSON()}`);
  }
  return model;
}

/**
 * Class method which reads an Entity by its a key.
 * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
 * @param {*} key
 * @returns An instance of the Class or undefined
 */
Model.findAtMostOne = async function(key, options) {
  let models = await this.findAll(key, options);
  if (models.length > 1) {
    throw new MultipleRecordsFoundException(`Multiple Records Found on ${this.name} with Key ${key.toJSON()}`);
  }
  return models[0];
}

/**
 * Class method to search for a entity based on the object & values provided
 * @param {*} attributes
 * @return {array<Model>}
 */
Model.findAll = async function(attributes, options) {

  options = {...options};
  options.includes = options.includes || [];
  this._validateIncludes(options.includes);

  let rows = await Query.select(this, attributes, options);

  const _self = this;
  return rows.map((data) => {
    let model = new _self(data);
    model._isNewRecord = false;
    return model;
  });
}

/**
 * Class method to validate includes options during a find
 * @param {Array<string>}     includes Array of reference of associations with this model
 */
Model._validateIncludes = async function(includes) {
  includes.forEach((include) => {
    if(!this.associations[include]){
      throw new Error(`${include} is not associated with the model - ${this.name}`);
    }
  })
}

/**
 * Class method to count the number of rows which have the given attributes
 * @param {*} key
 * @return {integer} number of rows
 */
Model.count = async function(attributes, options) {
  return Query.count(this, attributes);
}

/**
 * Creates a entry on this table
 * @param {object} entity
 * @returns {Promise<Number>} A promise which resolves to an ID of an entity
 */
Model.create = async function(entity) {
  let filteredEntity = this._filterAttributesByDefinition(entity);
  await this.beforeCreate(filteredEntity);
  let result = await Query.create(this, filteredEntity);

  if (result.length !== 1) {
    throw new Error(this.name + ' insertion failed');
  }
  return new this(result[0]);
}

/**
 * Updates a entry on this table
 * @param {object} entity containing a valid id and the details to update to
 * @returns {Promise<*>}
 */
Model.modify = async function(entity) {
  let filteredEntity = this._filterAttributesByDefinition(entity);
  let rows = await Query.modify(this, entity.id, filteredEntity);

  if (rows.length !== 1) {
    throw new Error(this.name + ' modification failed');
  }
  let model = new this(rows[0]);
}

/**
 * Delete a entry on this table
 * @param {Number} ID of the entity to delete
 * @returns {Promise<>}
 */
Model.delete = async function(id) {
  await Query.delete(this, id);
}

Model.sync = async function(){
  return Query.createTableIfNotExists(this);
}


/************************************************************************************
******                       MODEL INSTANCE METHODS                           ******
************************************************************************************/

/**
 * Constructor
 */
function Model(values = {}, options = {}) {
  Util.defineNonEnumerableProperty(this, '_dataAttributes', this._getDataAttributes(values));
  Util.defineNonEnumerableProperty(this, '_options', options);
  Util.defineNonEnumerableProperty(this, '_isNewRecord', true);
};

/**
 * Gets the models internal value of an attribute.
 * @param {string} key name of the attribute
 * @param {object} options
 */
function get(key, options) {
  return this._dataAttributes[key].value;
}
Util.defineNonEnumerableProperty(Model.prototype, 'get', get);

/**
 * Sets the models internal value of an attribute.
 * @param {string} key name of the attribute
 * @param {any} value to set
 * @param {object} options
 */
function set(key, value, options) {
  // console.log('set', key, value);
  this._dataAttributes[key].value = value;
}
Util.defineNonEnumerableProperty(Model.prototype, 'set', set);

function _getDataAttributes(values = {}) {
  const attributes = {};
  Object.keys(values).forEach((key) => {
    attributes[key] = new Attribute(values[key]);
  })
  return attributes;
}
Util.defineNonEnumerableProperty(Model.prototype, '_getDataAttributes', _getDataAttributes);

/**
 * Returns Object which contains only the attributes which are configured
 */
function toJSON() {
  let object = {};
  Object.keys(this.constructor.rawAttributes).forEach((attributeName) => {
    object[attributeName] = this.get(attributeName);
  });
  return object;
}
Util.defineNonEnumerableProperty(Model.prototype, 'toJSON', toJSON);

/**
 * Gets a string representation of this model
 */
function toString() {
  return `Model ${this.constructor.name} - ${JSON.stringify(this.toJSON())}`;
}
Util.defineNonEnumerableProperty(Model.prototype, 'toString', toString);
