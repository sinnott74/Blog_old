const DataTypes = require('./DataTypes');
const Sql = require('sql');
const Query = require('./Query');
const Associations = require('./Associations');
const RecordNotFoundException = require('../../exception/RecordNotFoundException');
const MultipleRecordsFoundException = require('../../exception/RecordNotFoundException');

/**
 * Defines a Database entity
 */
class Model {

  /************************************************************************************
   ******                         MODEL CLASS METHODS                            ******
   ************************************************************************************/

  /**
   * Class method which Initialize a model, representing a table in the DB, with attributes and options.
   *
   * For a list of possible data types, see {@link DataTypes}
   * @return {Model}
   */
  static init(attributes, options) {

    if (!options.modelName) {
      throw new Error('Model name required');
    }
    Object.defineProperty(this, 'name', {value: options.modelName}); // Define object name

    this.options = {
      schema: 'public',
      indexes: [],
      timestamps: false, // adding createdAt & updatedAt attributes
      optimisticLocking: false,
      ...options
    }

    this.associations = {};

    this.rawAttributes = {
      ...attributes
    };

    this._configureCommonAttributes();
    this._configureAttributeGettersAndSetters();
    this.refreshAttributes();
  }

  /**
   * Class methor which Configures the common attributes. e.g. id, versionNo, etc
   * Requires this.attributes & this.options have been set
   */
  static _configureCommonAttributes() {

    // Add ID - Primary Key
    this.rawAttributes = {
      id: {
        type: DataTypes.INT,
        notNull: true,
        primaryKey: true,
        autoIncrement: true,
        _autoGenerated: true
      },
      ...this.rawAttributes
    }

    // Add createdAt & updatedAt attributes
    if(this.options.timestamps) {
      this.rawAttributes = {
        ...this.rawAttributes,
        createdAt: {
          type: DataTypes.TIMESTAMP,
          notNull: true,
          _autoGenerated: true

        },
        updatedAt: {
          type: DataTypes.TIMESTAMP,
          notNull: true,
          _autoGenerated: true
        }
      }
    }

    // Add versionNo attribute
    if(this.options.optimisticLocking){
      this.rawAttributes = {
        ...this.rawAttributes,
        versionNo: {
          type: DataTypes.INT,
          notNull: true,
          defaultValue: 0,
          _autoGenerated: true
        }
      }
    }
  }

  /**
   * Class method which Adds a getter & setter for each raw attribute onto the model's prototype.
   *
   * Also adds an custom raw attribute getter & setter onto the model's prototypes _custom property.
   */
  static _configureAttributeGettersAndSetters() {

    // Create getter & setters for attributes
    Object.keys(this.rawAttributes).forEach((attributeName) => {

      let attribute = this.rawAttributes[attributeName];

      // Define normal getter & setters
      Object.defineProperty(this.prototype, attributeName, {
        get: function() {
          // console.log('In getter');
          return this.get(attributeName);
        },
        set: function(value) {
          this.set(attributeName, value);
        }
      });

      // Define custom attribute getters & setters
      // if (attribute.hasOwnProperty('get')) {
      //   this.prototype._customGetters[attributeName] = attribute.get;
      // }
      // if (attribute.hasOwnProperty('set')) {
      //   this.prototype._customSetters[attributeName] = attribute.set;
      // }
    })

    // TODO
    // Create custom properties/attributes
  }

  /**
   * Class method which Converts the Raw Attributes & Options in a object that is exected by the Package SQL.
   */
  static _convertToSQLConiguration() {

    const columns = Object.keys(this.rawAttributes).map((attributeName) => {
      let attribute = this.rawAttributes[attributeName];
      return {
        name: attributeName,
        ...attribute,
        dataType: attribute.type.getSQLType(attribute)
      }
    })

    this.sqlConfig = {
      name: this.options.modelName,
      schema: this.options.schema,
      columns
    };

    this.entity = Sql.define(this.sqlConfig);
  }

  static refreshAttributes() {
    this._convertToSQLConiguration();
  }

  /**
   * Filters out attributes which aren't defined in the Entity Definitiion
   * @param {*} entity
   * @returns {*} Entity which contains only attributes in the entity definitition
   */
  static _filterAttributesByDefinition(entity) {
    let attributes= Object.keys(entity);
    let definedAttributes = this.sqlConfig.columns.map(definedAttribute => definedAttribute.name);
    let filteredEntity = {};
    attributes.forEach((attribute) => {
      if(definedAttributes.includes(attribute)){
        filteredEntity[attribute] = entity[attribute];
      }
    });
    return filteredEntity;
  }

  /**
   * Class Method which reads a Entity by its primary key.
   * @param {Integer}     id ID of the entity
   * @throws RecordNotFoundException if no row with the given primary key is found
   * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
   */
  static async get(id, options) {
    return this.findOne({id: id}, options);
  }

  /**
   * Class Method which reads a Entity by its primary key.
   * @param {object}     key Attribute - Value object of which only 1 record should exist
   * @throws RecordNotFoundException if no row with the given primary key is found
   * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
   * @return {Model}
   */
  static async findOne(key, options) {
    let model = await this.findAtMostOne(key, options);
    if (!model) {
      throw new RecordNotFoundException(`Record Not Found on ${this.name} with Key ${key.toJSON()}`);
    }
    return model;
  }

  /**
   * Class method which reads an Entity by its a key.
   * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
   * @param {*} key
   * @returns {array<Model>} containing 0 or 1 models
   */
  static async findAtMostOne(key, options) {
    let models = await this.findAll(key, options);
    if (models.length > 1) {
      throw new MultipleRecordsFoundException(`Multiple Records Found on ${this.name} with Key ${key.toJSON()}`);
    }
    return models[0];
  }

  /**
   * Class method to search for a entity based on the object & values provided
   * @param {*} attributes
   * @return {array<Model>}
   */
  static async findAll(attributes, options) {

    options = {...options};
    options.includes = options.includes || [];
    this._validateIncludes(options.includes);

    let rows = await Query.select(this, attributes, options);

    return rows.map((data) => {
      let model = new this(data);
      model._isNewRecord = false;
      return model;
    });
  }

  /**
   * Class method to validate includes options during a find
   * @param {Array<string>}     includes Array of reference of associations with this model
   */
  static _validateIncludes(includes) {
    includes.forEach((include) => {
      if(!this.associations[include]){
        throw new Error(`${include} is not associated with the model - ${this.name}`);
      }
    })
  }

  /**
   * Class method to count the number of rows which have the given attributes
   * @param {*} key
   * @return {integer} number of rows
   */
  static async count(attributes, options) {
    return Query.count(this, attributes);
  }

  /**
   * Creates a entry on this table
   * @param {object} entity
   * @returns {Promise<Number>} A promise which resolves to an ID of an entity
   */
  static async create(entity) {
    let filteredEntity = this._filterAttributesByDefinition(entity);
    await this.beforeCreate(filteredEntity);
    let result = await Query.create(this, filteredEntity);

    if (result.length !== 1) {
      throw new Error(this.name + ' insertion failed');
    }
    return new this(result[0]);
  }

  /**
   * Updates a entry on this table
   * @param {object} entity containing a valid id and the details to update to
   * @returns {Promise<*>}
   */
  static async modify(entity) {
    let filteredEntity = this._filterAttributesByDefinition(entity);
    let rows = await Query.modify(this, entity.id, filteredEntity);

    if (rows.length !== 1) {
      throw new Error(this.name + ' modification failed');
    }
    let model = new this(rows[0]);
  }

  /**
   * Delete a entry on this table
   * @param {Number} ID of the entity to delete
   * @returns {Promise<>}
   */
  static async delete(id) {
    await Query.delete(this, id);
  }

  static async sync(){
    return Query.createTableIfNotExists(this);
  }

  /**
   * @Implementable hook points
   */
  static async beforeCreate() {}

  /**
   * Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.
   *
   * @param {Model}               model
   * @example
   * User.hasMany(Profile) // This will add userId to the profile table
   */
  static oneToMany(model, options) {
    options = {...options};
    let name = options.as ? options.as : this.name;
    model.associations[name] = new Associations.OneToMany(this, model, options);
  }

  /**
   *
   * @param {Model} model
   */
  static oneToOne(model, options) {
    options = {...options};
    let name = options.as ? options.as : this.name;
    model.associations[name] = new Associations.OneToOne(this, model, options);
  }

  /**
   *
   * @param {Model} model
   */
  static manyToMany(model, options) {
    options = {...options};
    let name = options.as ? options.as : this.name;
    model.associations[name] = new Associations.ManyToMany(this, model, options);
  }


  /************************************************************************************
   ******                       MODEL INSTANCE METHODS                           ******
   ************************************************************************************/

  /**
   * Gets the models internal value of an attribute.
   * @param {string} key name of the attribute
   * @param {object} options
   */
  get(key, options) {
    // console.log('get', key);
    return this._dataValues[key];
  }

  /**
   * Sets the models internal value of an attribute.
   * @param {string} key name of the attribute
   * @param {any} value to set
   * @param {object} options
   */
  set(key, value, options) {
    // console.log('set', key, value);
    this._dataValues[key] = value;
  }

  /**
   * Creates an instance of the model
   *
   * @constructor
   * @param {*} values
   * @param {*} options
   */
  constructor(values, options) {
    this._dataValues = values || {};
    this._options = options || {};
    this._isNewRecord = true;
  }

  /**
   * Returns Object which contains only the attributes which are configured
   */
  toJSON() {
    let object = {};
    Object.keys(this.constructor.rawAttributes).forEach((attributeName) => {
      object[attributeName] = this.get(attributeName);
    });
    return object;
  }

  /**
   * Gets a string representation of this model
   */
  toString() {
    return `Model ${this.constructor.name} - ${JSON.stringify(this.toJSON())}`;
  }
}
module.exports = Model;