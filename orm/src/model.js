module.exports = Model;

const DataTypes = require("./datatypes");
const Sql = require("sql");
const Query = require("./query");
const Attribute = require("./attribute");
const Util = require("./util");
const Exceptions = require("./exceptions");
const RecordNotFoundException = Exceptions.RecordNotFoundException;
const MultipleRecordsFoundException = Exceptions.MultipleRecordsFoundException;

require("./associations");
require("./hooks");

/************************************************************************************
 ******                         MODEL CLASS METHODS                            ******
 ************************************************************************************/

/**
 * Class method which Initialize a model, representing a table in the DB, with attributes and options.
 *
 * For a list of possible data types, see {@link DataTypes}
 * @return {Model}
 */
Model.init = function(attributes, options) {
  if (!options.modelName) {
    throw new Error("Model name required");
  }
  Util.defineImmutableProperty(this, "name", options.modelName);

  this.options = {
    schema: "public",
    indexes: [],
    timestamps: false, // adding createdAt & updatedAt attributes
    optimisticLocking: false,
    ...options
  };

  this.associations = {};

  this.rawAttributes = {
    ...attributes
  };

  this._configureCommonAttributes();
  this._configureAttributeGettersAndSetters();
  this.refreshAttributes();
};

/**
 * Class methor which Configures the common attributes. e.g. id, versionNo, etc
 * Requires this.attributes & this.options have been set
 */
Model._configureCommonAttributes = function() {
  // Add ID - Primary Key
  this.rawAttributes = {
    id: {
      type: DataTypes.INT,
      notNull: true,
      primaryKey: true,
      autoIncrement: true,
      _autoGenerated: true
    },
    ...this.rawAttributes
  };

  // Add createdAt & updatedAt attributes
  if (this.options.timestamps) {
    this.rawAttributes = {
      ...this.rawAttributes,
      createdAt: {
        type: DataTypes.TIMESTAMP,
        notNull: true,
        _autoGenerated: true
      },
      updatedAt: {
        type: DataTypes.TIMESTAMP,
        notNull: true,
        _autoGenerated: true
      }
    };
  }

  // Add versionNo attribute
  if (this.options.optimisticLocking) {
    this.rawAttributes = {
      ...this.rawAttributes,
      versionNo: {
        type: DataTypes.INT,
        notNull: true,
        defaultValue: 0,
        _autoGenerated: true
      }
    };
  }
};

/**
 * Class method which Adds a getter & setter for each raw attribute onto the model's prototype.
 *
 * Also adds an custom raw attribute getter & setter onto the model's prototypes _custom property.
 */
Model._configureAttributeGettersAndSetters = function() {
  // Create getter & setters for attributes
  const _self = this;
  Object.keys(_self.rawAttributes).forEach(attributeName => {
    let attribute = _self.rawAttributes[attributeName];
    Util.defineGetterAndSetter(_self, attributeName);
  });

  // Create custom properties/attributes
  if (this.options.customAttributes) {
    const customAttributes = this.options.customAttributes;
    Object.keys(customAttributes).forEach(customAttribute => {
      const action = customAttributes[customAttribute];
      Object.defineProperty(_self.prototype, customAttribute, {
        get: action.get,
        set: action.set,
        enumerable: true
      });
    });
  }
};

/**
 * Class method which Converts the Raw Attributes & Options in a object that is exected by the Package SQL.
 */
Model._convertToSQLConiguration = function() {
  const columns = Object.keys(this.rawAttributes).map(attributeName => {
    let attribute = this.rawAttributes[attributeName];
    return {
      name: attributeName,
      ...attribute,
      dataType: attribute.type.getSQLType(attribute)
    };
  });

  this.sqlConfig = {
    name: this.options.modelName,
    schema: this.options.schema,
    columns
  };

  this.entity = Sql.define(this.sqlConfig);
};

Model.refreshAttributes = function() {
  this._convertToSQLConiguration();
};

/**
 * Class Method which reads a Entity by its primary key.
 * @param {Integer}     id ID of the entity
 * @throws RecordNotFoundException if no row with the given primary key is found
 * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
 */
Model.get = async function(id, options) {
  return this.findOne({ id: id }, options);
};

/**
 * Class Method which reads a Entity by its primary key.
 * @param {object}     key Attribute - Value object of which only 1 record should exist
 * @throws RecordNotFoundException if no row with the given primary key is found
 * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
 * @return {Model}
 */
Model.findOne = async function(key, options) {
  let model = await this.findAtMostOne(key, options);
  if (!model) {
    throw new RecordNotFoundException(
      `Record Not Found on ${this.name} with Key ${JSON.stringify(key)}`
    );
  }
  return model;
};

/**
 * Class method which reads an Entity by its a key.
 * @throws MultipleRecordsFoundException if more than 1 row with the given primary key is found
 * @param {*} key
 * @returns An instance of the Class or undefined
 */
Model.findAtMostOne = async function(key, options) {
  let models = await this.findAll(key, options);
  if (models.length > 1) {
    throw new MultipleRecordsFoundException(
      `Multiple Records Found on ${this.name} with Key ${JSON.stringify(key)}`
    );
  }
  return models[0];
};

/**
 * Class method to search for a entity based on the object & values provided
 * @param {*} attributes
 * @return {array<Model>}
 */
Model.findAll = async function(attributes, options) {
  options = { ...options };
  options.includes = options.includes || [];
  this._validateIncludes(options.includes);

  let rows = await Query.select(this, attributes, options);

  const _self = this;
  return rows.map(data => {
    let model = new _self(data);
    model._clean();
    return model;
  });
};

/**
 * Class method to validate includes options during a find
 * @param {Array<string>}     includes Array of reference of associations with this model
 */
Model._validateIncludes = async function(includes) {
  includes.forEach(include => {
    if (!this.associations[include]) {
      throw new Error(
        `${include} is not associated with the model - ${this.name}`
      );
    }
  });
};

/**
 * Class method to count the number of rows which have the given attributes
 * @param {*} key
 * @return {integer} number of rows
 */
Model.count = async function(attributes, options) {
  return Query.count(this, attributes);
};

/**
 * Delete a entry on this table
 * @param {Number} ID of the entity to delete
 * @returns {Promise<>}
 */
Model.delete = async function(id) {
  await Query.delete(this, id);
};

Model.sync = async function() {
  return Query.createTableIfNotExists(this);
};

Model.buildFromDatabase = function(values) {
  const model = new this(values);
  Object.keys(model._dataAttributes).map(attributeName => {
    model._dataAttributes[attributeName].isDirty = false;
  });
};

/************************************************************************************
 ******                       MODEL INSTANCE METHODS                           ******
 ************************************************************************************/

/**
 * Constructor
 */
function Model(values = {}, options = {}) {
  const _self = this;

  Util.defineNonEnumerableProperty(this, "_dataAttributes", {});
  Util.defineNonEnumerableProperty(this, "_associationAttributes", {});
  Util.defineNonEnumerableProperty(this, "_options", options);

  const filteredValues = this._filterAttributesByDefinition(values);

  Object.keys(filteredValues).map(attribute => {
    _self[attribute] = values[attribute];
  });
}

Util.defineNonEnumerableProperty(Model.prototype, "get", get);
Util.defineNonEnumerableProperty(Model.prototype, "set", set);
Util.defineNonEnumerableProperty(Model.prototype, "save", save);
Util.defineNonEnumerableProperty(Model.prototype, "_save", _save);
Util.defineNonEnumerableProperty(Model.prototype, "_clean", _clean);
Util.defineNonEnumerableProperty(
  Model.prototype,
  "_getDirtyData",
  _getDirtyData
);
Util.defineNonEnumerableProperty(
  Model.prototype,
  "_filterAttributesByDefinition",
  _filterAttributesByDefinition
);
Util.defineNonEnumerableProperty(Model.prototype, "overwrite", overwrite);
Util.defineNonEnumerableProperty(Model.prototype, "toJSON", toJSON);
Util.defineNonEnumerableProperty(Model.prototype, "toString", toString);

/**
 * Updates the isDirty flag of all attributes to false. Should only be called when data is recieved from the database.
 * @See findAll
 */
function _clean() {
  Object.keys(this._dataAttributes).forEach(dataAttributeKey => {
    this._dataAttributes[dataAttributeKey].isDirty = false;
  });
  Object.keys(this._associationAttributes).forEach(associationAttributeKey => {
    this._associationAttributes[associationAttributeKey]._clean();
  });
}

/**
 * Gets the models internal value of an attribute.
 * @param {string} key name of the attribute
 * @param {object} options
 */
function get(key, options) {
  if (this._dataAttributes && this._dataAttributes[key]) {
    return this._dataAttributes[key].value;
  }
}

/**
 * Sets the models internal value of an attribute.
 * @param {string} key name of the attribute
 * @param {any} value to set
 * @param {object} options
 */
function set(key, value, options) {
  // console.log('set', key, value);
  if (this._dataAttributes[key]) {
    this._dataAttributes[key].value = value;
  } else {
    this._dataAttributes[key] = new Attribute(key, value);
  }
}

async function save() {
  await this.constructor.beforeSave.call(this);

  // Call save on each association
  await Util.asyncForEach(
    Object.keys(this.constructor.associations),
    async associationKey => {
      if (this[associationKey]) {
        await this.constructor.associations[associationKey].save(this);
      }
    }
  );

  // Save this model's data
  await this._save();
  this._clean();

  await this.constructor.afterSave.call(this);
}

async function _save() {
  if (this.id) {
    await this.constructor.beforeUpdate.call(this);
    await Query.modify(this);
    await this.constructor.afterUpdate.call(this);
  } else {
    await this.constructor.beforeCreate.call(this);
    await Query.create(this);
    await this.constructor.afterCreate.call(this);
  }
}

/**
 * Gets object of attribute names to attribute values for each Dirty data attribute.
 */
function _getDirtyData() {
  const dirtyData = {};
  Object.keys(this._dataAttributes).forEach(key => {
    const attribute = this._dataAttributes[key];
    if (attribute.isDirty) {
      dirtyData[key] = attribute.value;
    }
  });
  return dirtyData;
}

/**
 * Filters out attributes which aren't defined in the Entity Definitiion
 * @param {*} entity
 * @returns {*} Entity which contains only attributes in the entity definitition
 */
function _filterAttributesByDefinition(attributes) {
  const filteredAttributes = {};

  Object.keys(attributes).forEach(attributeKey => {
    if (
      this.constructor.rawAttributes[attributeKey] ||
      this.constructor.associations[attributeKey]
    ) {
      filteredAttributes[attributeKey] = attributes[attributeKey];
    }
  });

  return filteredAttributes;
}

/**
 * Overwrites this model with the values of the given model & aligns the isDirty flag.
 * @param {Model} model
 */
function overwrite(model) {
  for (const attributeKey in model) {
    this[attributeKey] = model[attributeKey];

    // Set dirty flag
    if (this._dataAttributes[attributeKey]) {
      this._dataAttributes[attributeKey].isDirty =
        model._dataAttributes[attributeKey].isDirty;
    }
  }
}

/**
 * Returns Object which contains only the attributes which are configured
 */
function toJSON() {
  let object = {};
  // loop through enumerable properties
  for (key in this) {
    const value = this[key];
    if (value instanceof Object) {
      object[key] = value.toJSON();
    } else {
      object[key] = value;
    }
  }
  return object;
}

/**
 * Gets a string representation of this model
 */
function toString() {
  return `Model ${this.constructor.name} - ${JSON.stringify(this.toJSON())}`;
}
