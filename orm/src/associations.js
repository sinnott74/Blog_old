/**
 * Association mixins for Model
 */
const ORM = require('./orm');
const Model = require('./model');
const Util = require('./util');
const DataTypes = require('./datatypes');

/**
 *
 * @param {Model} model
 */
Model.oneToOne = function(model, options) {
  new OneToOne(this, model, options);
}

/**
 * Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.
 *
 * @param {Model}               model
 * @example
 * User.hasMany(Profile) // This will add userId to the profile table
 */
Model.oneToMany = function(model, options) {
  new OneToMany(this, model, options);
}

/**
 *
 * @param {Model} model
 */
Model.manyToMany = function(model, options) {
  new ManyToMany(this, model, options);
}

class AbstractAssociation {

  constructor(source, target, options) {
    this.source = source;
    this.target = target;
    this.options = options;
    this.name = this.getAssociationName(source, target, options);
    this.target.associations[this.name] = this;
  }

  /**
   * Gets the associations AS name.
   * @param {Model} source
   * @param {Model} target
   * @param {Object} options
   */
  getAssociationName(source, target, options) {
    return options.as ? options.as : source.name;
  }

  /**
   * Adds an foreign reference to the table of modelReferencing, referencing the table of modelBeingReferenced
   * @param {*} modelReferencing
   * @param {*} modelBeingReferenced
   */
  addModelReference(modelReferencing, modelBeingReferenced) {
    const foreignKeyName = `${modelBeingReferenced.name}_id`;
    const foreignKey = {
      type: DataTypes.INT,
      notNull: true,
      _autoGenerated: true,
      references: {
        table: modelBeingReferenced.name,
        column: 'id'
      }
    }

    modelReferencing.rawAttributes[foreignKeyName] = foreignKey;
    Util.defineGetterAndSetter(modelReferencing, foreignKeyName);
    modelReferencing.refreshAttributes();
  }
}

/**
 * Creates a OneToOne Association.
 */
class OneToOne extends AbstractAssociation {

  constructor(source, target, options = {}) {
    super(source, target, options);
    this.type = "OneToOne";
    this.addModelReference(target, source);
    if(this.options.bidirectional) {
      this.addModelReference(source, target);
    }
    this.defineGetterAndSetter(target, this.name);
  }

  /**
   * Adds a getter & setter onto the prototype of the given object.
   * @param {Model} model Model to add the getter & setter to
   * @param {String} name Attribute name
   */
  defineGetterAndSetter(model, name) {
    Object.defineProperty(model.prototype, name, {
      get: function() {
        return this._associationAttributes[name];
      },
      set: function(value) {
        if(Array.isArray(value) && value[0]){
          const item = value[0];
          if(item instanceof Model){
            this._associationAttributes[name] = value;
          } else {
            this._associationAttributes[name] = new this.constructor.associations[name].source(value);
          }
        } else if(value instanceof Model) {
          this._associationAttributes[name] = value;
        } else {
          this._associationAttributes[name] = new this.constructor.associations[name].source(value);
        }
      },
      enumerable: true
    })
  }
}

/**
 * Creates a OneToMany Association.
 */
class OneToMany extends AbstractAssociation {

  constructor(source, target, options = {}) {
    super(source, target, options);
    this.type = "OneToMany";
    this.addModelReference(target, source);
    this.defineGetterAndSetter(target, this.name);
  }

  /**
   * Adds a getter & setter onto the prototype of the given object.
   * @param {Model} model Model to add the getter & setter to
   * @param {String} name Attribute name
   */
  defineGetterAndSetter(model, name) {
    Object.defineProperty(model.prototype, name, {
      get: function() {
        return this._associationAttributes[name];
      },
      set: function(value) {
        if(Array.isArray(value) && value[0]){
          const item = value[0];
          if(item instanceof Model){
            this._associationAttributes[name] = value;
          } else {
            this._associationAttributes[name] = new this.constructor.associations[name].source(item);
          }
        } else if(value instanceof Model) {
          this._associationAttributes[name] = value;
        } else {
          this._associationAttributes[name] = new this.constructor.associations[name].source(value);
        }
      },
      enumerable: true
    })
  }
}

/**
 * Creates a ManyToMany Association.
 */
class ManyToMany extends AbstractAssociation {

  constructor(source, target, options = {}) {
    super(source, target, options);
    this.type = "ManyToMany";
    const throughName = options.through || source.name + target.name;
    this.through = this.constructor.getThroughModel(throughName);
    this.addModelReference(this.through, this.target);
    this.addModelReference(this.through, this.source);
  }

  /**
   * Name of the Model which the Many to Many association goes through
   * @param {String} through
   */
  static getThroughModel(through) {
    if(!ORM.isDefined(through)){
      ORM.define(through, {});
    }
    return ORM.getModel(through);
  }
}