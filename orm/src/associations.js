/**
 * Association mixins for Model
 */
const ORM = require("./orm");
const Model = require("./model");
const Util = require("./util");
const DataTypes = require("./datatypes");

/**
 *
 * @param {Model} model
 */
Model.oneToOne = function(model, options) {
  new OneToOne(this, model, options);
};

/**
 * Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.
 *
 * @param {Model}               model
 * @example
 * User.hasMany(Profile) // This will add userId to the profile table
 */
Model.oneToMany = function(model, options) {
  new OneToMany(this, model, options);
};

/**
 *
 * @param {Model} model
 */
Model.manyToMany = function(model, options) {
  new ManyToMany(this, model, options);
};

class AbstractAssociation {
  constructor(source, target, options) {
    this.source = source;
    this.target = target;
    this.options = options;
  }

  /**
   * Gets the associations AS name.
   * @param {Model} source
   * @param {Model} target
   * @param {Object} options
   */
  getAssociationName(source, target, options) {
    return options.as ? options.as : source.name;
  }

  /**
   * Adds an foreign reference to the table of modelReferencing, referencing the table of modelBeingReferenced
   * @param {*} modelReferencing
   * @param {*} modelBeingReferenced
   */
  addModelReference(modelReferencing, modelBeingReferenced) {
    const foreignKeyName = `${modelBeingReferenced.name}_id`;
    const foreignKey = {
      type: DataTypes.INT,
      notNull: true,
      _autoGenerated: true,
      references: {
        table: modelBeingReferenced.name,
        column: "id"
      }
    };

    modelReferencing.rawAttributes[foreignKeyName] = foreignKey;
    Util.defineGetterAndSetter(modelReferencing, foreignKeyName);
    modelReferencing.refreshAttributes();
  }

  /**
   * Given the source name will return the target, given the target name will return the source.
   * @param {Model} model
   */
  getRecipricalModel(modelName) {
    if (modelName === this.source.name) {
      return this.target;
    } else if (modelName === this.target.name) {
      return this.source;
    } else {
      return;
    }
  }

  /**
   * Single Join
   * @param {*} modelClass
   * @param {*} fromClause
   */
  join(modelClass, fromClause) {
    const recipricalModelClass = this.getRecipricalModel(modelClass.name);
    return fromClause
      .leftJoin(recipricalModelClass.entity)
      .on(
        recipricalModelClass.entity.id.equals(
          modelClass.entity[`${recipricalModelClass.name}_id`]
        )
      );
  }
}

/**
 * Creates a OneToOne Association.
 */
class OneToOne extends AbstractAssociation {
  constructor(source, target, options = {}) {
    super(source, target, options);
    this.type = "OneToOne";
    this.name = this.getAssociationName(source, target, options);
    this.target.associations[this.name] = this;
    this.addModelReference(target, source);
    if (this.options.bidirectional) {
      this.addModelReference(source, target);
    }
    this.defineGetterAndSetter(target, this.name);
  }

  /**
   * Adds a getter & setter onto the prototype of the given object.
   * @param {Model} model Model to add the getter & setter to
   * @param {String} name Attribute name
   */
  defineGetterAndSetter(modelClass, name) {
    const recipricalModelClass = this.getRecipricalModel(modelClass.name);
    Object.defineProperty(modelClass.prototype, name, {
      get: function() {
        return this._associationAttributes[name];
      },
      set: function(value) {
        if (Array.isArray(value) && value[0]) {
          const item = value[0];
          if (item instanceof Model) {
            this._associationAttributes[name] = value;
          } else {
            this._associationAttributes[name] = new recipricalModelClass(value);
          }
        } else if (value instanceof Model) {
          this._associationAttributes[name] = value;
        } else {
          this._associationAttributes[name] = new recipricalModelClass(value);
        }
      },
      enumerable: true
    });
  }

  /**
   * Save the associated model & sets the ID back on the given model
   * @param {Model} model
   */
  async save(model) {
    const referencedModel = model[this.name];
    await referencedModel.save();
    model[`${this.name}_id`] = referencedModel.id;
  }
}

/**
 * Creates a OneToMany Association.
 */
class OneToMany extends AbstractAssociation {
  constructor(source, target, options = {}) {
    super(source, target, options);
    this.type = "OneToMany";
    this.name = this.getAssociationName(source, target, options);
    this.target.associations[this.name] = this;
    this.addModelReference(target, source);
    this.defineGetterAndSetter(target, this.name);
  }

  /**
   * Adds a getter & setter onto the prototype of the given object.
   * @param {Model} model Model to add the getter & setter to
   * @param {String} name Attribute name
   */
  defineGetterAndSetter(modelClass, name) {
    const recipricalModelClass = this.getRecipricalModel(modelClass.name);
    Object.defineProperty(modelClass.prototype, name, {
      get: function() {
        return this._associationAttributes[name];
      },
      set: function(value) {
        if (Array.isArray(value) && value[0]) {
          const item = value[0];
          if (item instanceof Model) {
            this._associationAttributes[name] = value;
          } else {
            this._associationAttributes[name] = new recipricalModelClass(item);
          }
        } else if (value instanceof Model) {
          this._associationAttributes[name] = value;
        } else {
          this._associationAttributes[name] = new recipricalModelClass(value);
        }
      },
      enumerable: true
    });
  }

  /**
   * Save the associated model & sets the ID back on the given model
   * @param {Model} model
   */
  async save(model) {
    const referencedModel = model[this.name];
    await referencedModel.save();
    model[`${this.name}_id`] = referencedModel.id;
  }
}

/**
 * Creates a ManyToMany Association.
 */
class ManyToMany extends AbstractAssociation {
  constructor(source, target, options = {}) {
    super(source, target, options);
    this.type = "ManyToMany";
    this.source.associations[Util.puralize(this.target.name)] = this;
    this.target.associations[Util.puralize(this.source.name)] = this;
    const throughName = options.through || source.name + target.name;
    this.through = this.constructor.getThroughModel(throughName);
    this.addModelReference(this.through, this.target);
    this.addModelReference(this.through, this.source);
    this.defineGetterAndSetter(this.target, Util.puralize(this.source.name));
    this.defineGetterAndSetter(this.source, Util.puralize(this.target.name));
  }

  /**
   * Name of the Model which the Many to Many association goes through
   * @param {String} through
   */
  static getThroughModel(throughName) {
    if (!ORM.isDefined(throughName)) {
      ORM.define(throughName, {});
    }
    return ORM.getModel(throughName);
  }

  /**
   * Adds a getter & setter onto the prototype of the given object.
   * @param {Model} model Model to add the getter & setter to
   * @param {String} name Attribute name
   */
  defineGetterAndSetter(modelClass, name) {
    const recipricalModelClass = this.getRecipricalModel(modelClass.name);
    Object.defineProperty(modelClass.prototype, name, {
      get: function() {
        return this._associationAttributes[name];
      },
      set: function(values) {
        if (values) {
          this._associationAttributes[name] = [];
          values.forEach(value => {
            if (value instanceof Model) {
              this._associationAttributes[name] = value;
            } else {
              const model = new recipricalModelClass(value);
              this._associationAttributes[name].push(model);
            }
          });
        } else {
          this._associationAttributes[name] = null;
        }
      },
      enumerable: true
    });
  }

  async save(model) {
    // Save this instance to get an ID
    await model._save();

    const modelClassName = model.constructor.name;
    const recipricalModelClassName = this.getRecipricalModel(modelClassName)
      .name;

    const referenceModels = model[Util.puralize(recipricalModelClassName)];

    // Delete Join table for this model
    await this.through.delete({ [`${modelClassName}_id`]: model.id });

    const throughInstances = [];

    await Util.asyncForEach(referenceModels, async referencedModel => {
      await referencedModel.save();
      const throughData = {
        [`${modelClassName}_id`]: model.id,
        [`${recipricalModelClassName}_id`]: referencedModel.id
      };
      const throughInstance = new this.through(throughData);
      throughInstances.push(throughInstance);
    });

    await this.through.insertAll(throughInstances);
  }

  /**
   * Many Join
   * @param {*} modelClass
   * @param {*} fromClause
   */
  join(modelClass, fromClause) {
    const recipricalModelClass = this.getRecipricalModel(modelClass.name);
    const throughModelClass = this.through;
    return fromClause
      .leftJoin(throughModelClass.entity)
      .on(
        throughModelClass.entity[`${modelClass.name}_id`].equals(
          modelClass.entity.id
        )
      )
      .leftJoin(recipricalModelClass.entity)
      .on(
        throughModelClass.entity[`${recipricalModelClass.name}_id`].equals(
          recipricalModelClass.entity.id
        )
      );
  }
}
